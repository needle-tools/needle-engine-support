# Messages

<sample src="https://engine.needle.tools/samples-uploads/networking-messages/" :split="true"/>

There are two types of messages:
 - ``TEXT`` - json objects
 - ``BINARY`` - flatbuffers

Overall, it is more performent to use ``Binary`` messages but it is simpler to debug and use ``Text`` messages. The main difference is in bandwidth where ``Text`` messages take more data to express the same information.

## Persistency

Messages can be stored on the server in the ``state`` which is sent every time a new user joins a room. This means that you can choose how important a given message is. Like, if the information in it should be available to all users right from their session start. An example would be a door's open and close states where new users should immediately receive the most up-to-date information and apply it. 

If a message has a `guid` property, that means it is persistent and the guid will be used as a unique key in the internal state storage. If you have two messages with the same guid, it will override the state with the newest received. Think of the guid as an information slot on the server. So given the example, every door should have its unique guid to store its open/close state.

Example of a message payload that has guid:
```json
{
    "guid": "20464c1c1d2144c898f82b4d90f34574",
    "propertyA": "dataA",
    "propertyB": "dataB"
}
```

You can also delete the state from the server by calling `this.context.connection.sendDeleteRemoteState(guid)`.

## Sending and receiving Text messages

### Sending a text message

You can send an object, number, boolean or string. Also, nothing can be supplied if you only want to send a signal.
Mind that you have to specify the `key` which is the message ID, examples are generic information like "roundEnd" or a GUID of a specific instance you want to communicate with.

<!-- SAMPLE network messages send -->

### Receiving
In order to receive a message, you need to subscribe to a message ID.

<!-- SAMPLE network messages receive -->

## Sending and receiving Binary messages

[Flatbuffers](https://flatbuffers.dev/) is a useful library which allows you to structure binary data into a hierarchy. It works by specifying a scheme based on which a helper API is generated for your specific language. 

### Writing schemas
You have to learn about [writing schemas](https://google.github.io/flatbuffers/flatbuffers_guide_writing_schema.html), which is an essential step to understand what is and what isn't possible.

Our sample uses this scheme, so let's take it as an example:
(Flatbuffer schemes have the .fsb extension)
```cs
table SendBuffer_Model {
    guid:[ubyte];
    dont_save:bool;
    prefix:string;
    seconds:int;
}

root_type SendBuffer_Model;
```

### Generating the API

The ``SendBuffer_Model.ts`` is generated by the flatbuffer CLI utility called [flatc, which is available on github](https://github.com/google/flatbuffers/releases).

Run the following command to generate the API: `flatc --ts file.fsb`

For more information please refer to this guide on how to [use the schema compiler](https://google.github.io/flatbuffers/flatbuffers_guide_using_schema_compiler.html).

### Using the API

- [Flatbuffer in Typescript](https://google.github.io/flatbuffers/flatbuffers_guide_use_typescript.html)

#### Construct a buffer and send it
<!-- SAMPLE network flatbuffer create and send -->

#### Recieve a buffer

First, you need to register the Model with the ID the messages will be generated with.
*(Mind that the code is put outside of the class so it happens only once upon the app start)*
<!-- SAMPLE network flatbuffer id register -->

And then you are able to start listening like so:

<!-- SAMPLE network flatbuffer receive -->
