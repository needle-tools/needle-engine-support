<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Playground</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { width: 100%; height: 100%; overflow: hidden; }
        needle-engine { width: 100%; height: 100%; }
        #err {
            position: absolute; bottom: 0; left: 0; right: 0;
            padding: 10px; background: rgba(60,0,0,0.95); color: #f66;
            font: 12px monospace; display: none; z-index: 10; max-height: 30%;
            overflow: auto;
        }
        #err.show { display: block; }
    </style>
    <!-- Load Needle Engine via CDN script tag (pre-bundled) -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@needle-tools/engine@4.5.0-alpha.7/dist/needle-engine.min.js"></script>
</head>
<body>
    <needle-engine></needle-engine>
    <div id="err"></div>

    <script type="module">
        // Wait for Needle Engine to be loaded
        await customElements.whenDefined('needle-engine');

        const Needle = globalThis.Needle;
        const THREE = globalThis.THREE;

        // Provide a no-op serializable decorator for playground use
        // (full serialization isn't needed - we just run the code)
        const serializable = (type) => (target, propertyKey) => {};

        // Make available globally for user code
        window.Behaviour = Needle.Behaviour;
        window.serializable = serializable;
        window.THREE = THREE;

        const engine = document.querySelector('needle-engine');

        let component = null;
        let targetObject = null;
        let context = null;

        function showError(msg) {
            document.getElementById('err').textContent = msg;
            document.getElementById('err').classList.add('show');
            parent.postMessage({ type: 'needle-playground-error', error: msg }, '*');
        }

        function hideError() {
            document.getElementById('err').classList.remove('show');
        }

        engine.addEventListener('ready', async () => {
            context = engine.context;
            console.log('[playground] Needle Engine ready', context);

            if (!context) {
                showError('Failed to get Needle Engine context');
                return;
            }

            // Find or create a target object for the component
            const scene = context.scene;
            scene.traverse((obj) => {
                if (!targetObject && obj.isMesh) {
                    targetObject = obj;
                }
            });

            if (!targetObject) {
                // Create a simple cube
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshStandardMaterial({ color: 0x99CC33, roughness: 0.5 });
                targetObject = new THREE.Mesh(geometry, material);
                targetObject.position.y = 0.5;
                scene.add(targetObject);

                // Add grid
                const grid = new THREE.GridHelper(10, 10, 0x444444, 0x333333);
                scene.add(grid);
            }

            // Tell parent we're ready
            parent.postMessage({ type: 'needle-playground-ready' }, '*');
        });

        // Handle incoming transpiled code
        addEventListener('message', async (e) => {
            if (!e.data || typeof e.data !== 'object') return;
            if (e.data.type !== 'needle-playground-code') return;
            console.log('[playground] Received code update');

            hideError();

            // Reset target object transform
            if (targetObject) {
                targetObject.rotation.set(0, 0, 0);
                targetObject.position.set(0, 0.5, 0);
                targetObject.scale.set(1, 1, 1);
            }

            let code = e.data.code;

            try {
                // Remove import statement - we provide globals
                code = code.replace(/import\s*\{[^}]*\}\s*from\s*["']@needle-tools\/engine["'];?/g, '');

                // Find the class name from "export { ClassName };" pattern
                const exportMatch = code.match(/export\s*\{\s*(\w+)\s*\}/);
                const className = exportMatch ? exportMatch[1] : 'Rotator';

                // Remove export statement
                code = code.replace(/export\s*\{\s*\w+\s*\};?/g, '');

                // Wrap in IIFE to avoid redeclaration errors
                code = `(function() {\n${code}\nwindow.__PlaygroundClass = ${className};\n})();`;

                // Execute via script tag
                const script = document.createElement('script');
                script.textContent = code;
                document.body.appendChild(script);
                document.body.removeChild(script);

                const ComponentClass = window.__PlaygroundClass;
                delete window.__PlaygroundClass;

                if (!ComponentClass) {
                    showError(`No ${className} class found in code`);
                    return;
                }

                // Destroy previous component
                if (component && component.onDisable) {
                    try { component.onDisable(); } catch(e) {}
                }

                // Create instance with Needle Engine context
                const instance = new ComponentClass();
                instance.gameObject = targetObject;
                instance.context = context;
                instance.enabled = true;

                if (instance.awake) instance.awake();
                if (instance.onEnable) instance.onEnable();
                if (instance.start) instance.start();

                component = instance;

            } catch (e) {
                console.error('Execution error:', e);
                showError(e.message);
                component = null;
            }
        });

        // Update loop
        function animate() {
            requestAnimationFrame(animate);
            if (component && component.enabled && component.update) {
                try {
                    component.update();
                } catch (e) {
                    showError('Runtime: ' + e.message);
                    component = null;
                }
            }
        }
        animate();
    </script>
</body>
</html>
