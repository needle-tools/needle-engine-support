import{_ as s,c as r,e as i,a,d as n,b as l,w as d,r as h,o}from"./app-9T6lAodh.js";const p={};function c(u,e){const t=h("RouteLink");return o(),r("div",null,[e[3]||(e[3]=i('<h1 id="assets-animationen-prefabs-materialien-lightmaps-exportieren..." tabindex="-1"><a class="header-anchor" href="#assets-animationen-prefabs-materialien-lightmaps-exportieren..."><span>Assets, Animationen, Prefabs, Materialien, Lightmaps exportieren...</span></a></h1><p>F√ºgen Sie Ihrer Unity-Szene eine <code>ExportInfo</code>-Komponente hinzu, um ein neues Webprojekt aus einem Template zu generieren, einen Link zu einem vorhandenen Webprojekt herzustellen, in das Sie exportieren m√∂chten, Abh√§ngigkeiten zu anderen Bibliotheken und Paketen einzurichten und Ihr Projekt bereitzustellen.</p><p>Standardm√§√üig wird Ihre Szene beim Speichern exportiert. Diese Einstellung kann ge√§ndert werden, indem <code>Auto Export</code> in der <code>ExportInfo</code>-Komponente deaktiviert wird.</p><h2 id="gltf-dateien-exportieren" tabindex="-1"><a class="header-anchor" href="#gltf-dateien-exportieren"><span>üì¶ glTF-Dateien exportieren</span></a></h2><p>Um Meshes, Materialien, Animationen, Texturen (...) zu exportieren, erstellen Sie ein neues GameObject in Ihrer Hierarchie und f√ºgen Sie ihm eine <code>GltfObject</code>-Komponente hinzu. Dies ist die Wurzel einer neuen glTF-Datei. Sie wird jedes Mal exportiert, wenn Sie eine √Ñnderung an der Szene vornehmen und speichern.</p><p>Nur Skripte und Daten auf und innerhalb dieser Wurzelobjekte werden exportiert. Skripte und Daten au√üerhalb davon werden nicht exportiert.</p><p>F√ºgen Sie Ihrem Wurzelobjekt einen W√ºrfel als Kind hinzu und speichern Sie Ihre Szene. Beachten Sie, dass der Ausgabeordner <code>assets/</code> (siehe <a href="#vite-project-structure">Projektstruktur</a>) nun eine neue <code>.glb</code>-Datei mit demselben Namen wie Ihr Wurzel-GameObject enth√§lt.</p><p>Sie k√∂nnen die Einstellung <code>Smart Export</code> (√ºber <code>Edit/Project Settings/Needle</code>) aktivieren, um nur zu exportieren, wenn eine √Ñnderung in der Hierarchie dieses Objekts erkannt wird.</p><details class="hint-container details"><summary>Wie man verhindert, dass bestimmte Objekte exportiert werden</summary><p>Objekte mit dem Tag <code>EditorOnly</code> werden beim Export ignoriert, einschlie√ülich ihrer Kindhierarchie. Beachten Sie, dass dies dem Deaktivieren von Objekten vorzuziehen ist, da deaktivierte Objekte weiterhin exportiert werden, falls sie sp√§ter wieder eingeschaltet werden.</p></details><h3 id="lazy-loading-und-mehrere-level-szenen" tabindex="-1"><a class="header-anchor" href="#lazy-loading-und-mehrere-level-szenen"><span>Lazy Loading und mehrere Level / Szenen</span></a></h3><p>Wenn Sie Ihre Anwendung in mehrere Level oder Szenen aufteilen m√∂chten, k√∂nnen Sie einfach die Komponente <code>SceneSwitcher</code> verwenden. Sie k√∂nnen Ihre Anwendung dann in mehrere Szenen oder Prefabs strukturieren und diese dem SceneSwitcher-Array hinzuf√ºgen, um zur Laufzeit geladen und entladen zu werden. Dies ist eine gro√üartige M√∂glichkeit, um nicht alle Inhalte auf einmal laden zu m√ºssen und die Ladezeiten gering zu halten (zum Beispiel haben wir das bei <a href="https://needle.tools?utm_source=needle_docs&amp;utm_content=export_scenes" target="_blank" rel="noopener noreferrer">needle.tools</a> gemacht, indem wir jeden Abschnitt unserer Website in eine eigene Szene unterteilt und diese nur bei Bedarf geladen haben).</p><h3 id="empfohlene-komplexit-t-pro-gltf" tabindex="-1"><a class="header-anchor" href="#empfohlene-komplexit-t-pro-gltf"><span>Empfohlene Komplexit√§t pro glTF</span></a></h3><ul><li>Max. 50 MB Exportgr√∂√üe unkomprimiert (endet normalerweise bei ~10-20 MB komprimiert)</li><li>Max. 500.000 Vertices (weniger, wenn Sie auch mobiles VR anvisieren)</li><li>Max. 4x 2k Lightmaps</li></ul>',13)),a("p",null,[e[1]||(e[1]=n("Sie k√∂nnen Szenen und Prefabs in mehrere glTF-Dateien aufteilen und diese dann bei Bedarf laden (nur wenn ben√∂tigt). Dies h√§lt die Ladeleistung schnell und die Dateigr√∂√üe klein. Siehe den Abschnitt ")),l(t,{to:"/lang/de/scripting.html#assetreference-and-addressables"},{default:d(()=>e[0]||(e[0]=[n("AssetReference in den Scripting-Docs")])),_:1}),e[2]||(e[2]=n("."))]),e[4]||(e[4]=i(`<p>Die hier empfohlene Szenenkomplexit√§t soll eine gute Leistung auf einer Reihe von webf√§higen Ger√§ten und Bandbreiten gew√§hrleisten. Es gibt keine technische Einschr√§nkung dar√ºber hinaus, als die F√§higkeiten Ihres Ger√§ts.</p><h3 id="prefabs" tabindex="-1"><a class="header-anchor" href="#prefabs"><span>Prefabs</span></a></h3><p>Prefabs k√∂nnen als einzelne glTF-Dateien exportiert und zur Laufzeit instanziiert werden. Um ein Prefab als glTF zu exportieren, referenzieren Sie einfach ein Prefab-Asset (aus dem Projektbrowser und nicht in der Szene) <a href="https://fwd.needle.tools/needle-engine/docs/addressables" target="_blank" rel="noopener noreferrer">aus einem Ihrer Skripte</a>.</p><p>Das Exportieren von Prefabs funktioniert auch mit Verschachtelung: Eine Komponente in einem Prefab kann ein anderes Prefab referenzieren, das dann ebenfalls exportiert wird. Dieser Mechanismus erm√∂glicht es, Szenen so leichtgewichtig wie m√∂glich zu gestalten und zuerst die wichtigsten Inhalte zu laden und das Laden zus√§tzlicher Inhalte zu verz√∂gern.</p><h3 id="scene-assets" tabindex="-1"><a class="header-anchor" href="#scene-assets"><span>Scene Assets</span></a></h3><p>√Ñhnlich wie Prefab Assets k√∂nnen Sie andere Scene Assets referenzieren. Erstellen Sie dazu in Unity eine Komponente mit einem Feld <code>UnityEditor.SceneAsset</code> und f√ºgen Sie diese einem Ihrer GameObjects innerhalb eines GltfObject hinzu. Die referenzierte Szene wird nun als separate glTF-Datei exportiert und kann als <code>AssetReference</code> aus TypeScript geladen/deserialisiert werden.</p><p>Sie k√∂nnen weiterhin in einer referenzierten Szene arbeiten und Ihre Haupt-Exporter-Szene/Website aktualisieren. Beim Speichern der Szene oder beim Wechsel des Play-Modus erkennen wir, ob die aktuelle Szene von Ihrem derzeit laufenden Server verwendet wird, und l√∂sen dann einen erneuten Export nur f√ºr dieses glb aus. (Diese Pr√ºfung erfolgt anhand des Namens - wenn eine glb in Ihrem Ordner <code>&lt;web_project&gt;/assets/</code> existiert, wird sie erneut exportiert und die Hauptszene l√§dt sie neu.)</p><p>Ein Beispiel auf <a href="https://needle.tools?utm_source=needle_docs&amp;utm_content=export_sceneassets" target="_blank" rel="noopener noreferrer">unserer Website</a>: Jeder Abschnitt ist als separate Szene eingerichtet und wird beim Export in mehrere glb-Dateien gepackt, die wir bei Bedarf laden:</p><p><img src="https://user-images.githubusercontent.com/5083203/185958983-71913c97-5eec-4cfd-99f5-76798582373e.png" alt="2022-08-22-172605_Needle_Website_-Website-_Windows,_Mac,Linux-_U"></p><h4 id="laden-eines-prefabs-oder-einer-szene-aus-einem-benutzerdefinierten-skript" tabindex="-1"><a class="header-anchor" href="#laden-eines-prefabs-oder-einer-szene-aus-einem-benutzerdefinierten-skript"><span>Laden eines Prefabs oder einer Szene aus einem benutzerdefinierten Skript</span></a></h4><p>Wenn Sie ein Prefab aus einem Ihrer Skripte referenzieren und laden m√∂chten, k√∂nnen Sie einen Typ <code>AssetReference</code> deklarieren. Hier ist ein minimales Beispiel:</p><div class="language-ts" data-highlighter="shiki" data-ext="ts" style="--shiki-light:#4c4f69;--shiki-dark:#c6d0f5;--shiki-light-bg:#eff1f5;--shiki-dark-bg:#303446;"><pre class="shiki shiki-themes catppuccin-latte catppuccin-frappe vp-code"><code><span class="line"><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;">import</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;"> {</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;"> Behaviour</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">,</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;"> serializable</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">,</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;"> AssetReference </span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">}</span><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;"> from</span><span style="--shiki-light:#40A02B;--shiki-dark:#A6D189;"> &quot;@needle-tools/engine&quot;</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;">export</span><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;"> class</span><span style="--shiki-light:#DF8E1D;--shiki-light-font-style:italic;--shiki-dark:#E5C890;--shiki-dark-font-style:italic;"> MyClass</span><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;"> extends</span><span style="--shiki-light:#DF8E1D;--shiki-light-font-style:italic;--shiki-dark:#E5C890;--shiki-dark-font-style:italic;"> Behaviour</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">    // if you export a prefab or scene as a reference from Unity you&#39;ll get a path to that asset</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">    // which you can de-serialize to AssetReference for convenient loading</span></span>
<span class="line"><span style="--shiki-light:#1E66F5;--shiki-light-font-style:italic;--shiki-dark:#8CAAEE;--shiki-dark-font-style:italic;">    @serializable</span><span style="--shiki-light:#FE640B;--shiki-dark:#EF9F76;">(</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">AssetReference</span><span style="--shiki-light:#FE640B;--shiki-dark:#EF9F76;">)</span></span>
<span class="line"><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">    myPrefab</span><span style="--shiki-light:#179299;--shiki-dark:#81C8BE;">?:</span><span style="--shiki-light:#DF8E1D;--shiki-light-font-style:italic;--shiki-dark:#E5C890;--shiki-dark-font-style:italic;"> AssetReference</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">;</span></span>
<span class="line"><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">    </span></span>
<span class="line"><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;">    async</span><span style="--shiki-light:#1E66F5;--shiki-light-font-style:italic;--shiki-dark:#8CAAEE;--shiki-dark-font-style:italic;"> start</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">()</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;"> {</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // directly instantiate</span></span>
<span class="line"><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;">      const</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;"> myInstance </span><span style="--shiki-light:#179299;--shiki-dark:#81C8BE;">=</span><span style="--shiki-light:#8839EF;--shiki-dark:#CA9EE6;"> await</span><span style="--shiki-light:#D20F39;--shiki-dark:#E78284;"> this</span><span style="--shiki-light:#179299;--shiki-dark:#81C8BE;">.</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">myPrefab</span><span style="--shiki-light:#179299;--shiki-dark:#81C8BE;">?.</span><span style="--shiki-light:#1E66F5;--shiki-light-font-style:italic;--shiki-dark:#8CAAEE;--shiki-dark-font-style:italic;">instantiate</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">()</span><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // you can also just load and instantiate later</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // const myInstance = await this.myPrefab.loadAssetAsync();</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // this.gameObject.add(myInstance)</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // this is useful if you know that you want to load this asset only once because it will not create a copy</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-light-font-style:italic;--shiki-dark:#949CBB;--shiki-dark-font-style:italic;">      // since \`\`instantiate()\`\` does create a copy of the asset after loading it</span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">    }</span><span style="--shiki-light:#4C4F69;--shiki-dark:#C6D0F5;">  </span></span>
<span class="line"><span style="--shiki-light:#7C7F93;--shiki-dark:#949CBB;">}</span></span></code></pre></div><h2 id="animationen-exportieren" tabindex="-1"><a class="header-anchor" href="#animationen-exportieren"><span>üèá Animationen exportieren</span></a></h2><p>Needle Engine unterst√ºtzt eine betr√§chtliche und leistungsstarke Untermenge von Unitys Animationsfunktionen:</p><ul><li><strong>Timeline</strong> inkl. Aktivierungs-Tracks, Animations-Tracks, Track-Offsets</li><li><strong>Animator</strong> inkl. √úberg√§nge zwischen Top-Level-States <ul><li>Blend Trees werden derzeit nicht unterst√ºtzt.</li><li>Sub State Machines werden derzeit nicht unterst√ºtzt.</li></ul></li><li><strong>AnimationClips</strong> inkl. Loop-Modi</li><li><strong>Prozedurale Animationen</strong> k√∂nnen per Skripting erstellt werden</li></ul><p>Needle Engine ist einer der Ersten, die die neue <a href="https://github.com/ux3d/glTF/tree/extensions/KHR_animation_pointer/extensions/2.0/Khronos/KHR_animation_pointer" target="_blank" rel="noopener noreferrer">glTF-Extension KHR_ANIMATION_POINTER</a> unterst√ºtzen. Das bedeutet, dass fast alle Eigenschaften, einschlie√ülich Skriptvariablen, animierbar sind.</p><p>Eine aktuelle Einschr√§nkung ist, dass Materialien beim Export nicht dupliziert werden ‚Äì wenn Sie dasselbe Material mit unterschiedlichen Farben animieren m√∂chten, m√ºssen Sie das Material derzeit in zwei Teile aufteilen.</p><h2 id="skybox-exportieren" tabindex="-1"><a class="header-anchor" href="#skybox-exportieren"><span>üåç Skybox exportieren</span></a></h2><p>Die Unity Skybox und benutzerdefinierte Reflexionen (falls vorhanden) werden beim Export in eine Textur gebacken und automatisch innerhalb der Extension <code>NEEDLE_lightmaps</code> exportiert.</p><p>Um die Skybox-Aufl√∂sung zu √§ndern, k√∂nnen Sie Ihrer Szene eine Komponente <code>SkyboxExportSettings</code> hinzuf√ºgen.</p><p><img src="https://user-images.githubusercontent.com/5083203/196030839-170a9496-9ed9-4ebc-bc1d-2df6c746f8c8.png" alt="image"></p><p>Wenn Sie nicht m√∂chten, dass die Skybox √ºberhaupt in einer glb-Datei exportiert wird, k√∂nnen Sie die Option <code>Embed Skybox</code> auf Ihrer <code>GltfObject</code>-Komponente deaktivieren.</p><p><img src="https://user-images.githubusercontent.com/5083203/196030825-8a05037f-5acc-4795-9128-2bdacedd0d49.png" alt="image"></p><h2 id="materialien-exportieren" tabindex="-1"><a class="header-anchor" href="#materialien-exportieren"><span>‚ú® Materialien exportieren</span></a></h2><h3 id="physically-based-materials-pbr" tabindex="-1"><a class="header-anchor" href="#physically-based-materials-pbr"><span>Physically Based Materials (PBR)</span></a></h3><p>Standardm√§√üig werden Materialien beim Export in glTF-Materialien konvertiert. glTF unterst√ºtzt ein physikalisch basiertes Materialmodell und verf√ºgt √ºber eine Reihe von Extensions, die helfen, komplexe Materialien darzustellen.</p><p>F√ºr volle Kontrolle dar√ºber, was exportiert wird, wird dringend empfohlen, die von UnityGltf bereitgestellten glTF-Materialien zu verwenden:</p><ul><li>PBRGraph</li><li>UnlitGraph</li></ul><div class="hint-container tip"><p class="hint-container-title">Im Zweifelsfall den PBRGraph Shader verwenden</p><p>Das PBRGraph-Material bietet viele Funktionen, weitaus mehr als Standard oder URP/Lit. Dazu geh√∂ren erweiterte Funktionen wie Brechung, Irisieren, Sheen und mehr. Dar√ºber hinaus werden Materialien, die PBRGraph und UnlitGraph verwenden, unver√§ndert exportiert, ohne dass eine Konvertierung erforderlich ist.</p></div><p>Materialien, die out-of-the-box konvertiert werden k√∂nnen:</p><ul><li>BiRP/Standard</li><li>BiRP/Autodesk Interactive</li><li>BiRP/Unlit</li><li>URP/Lit</li><li>URP/Unlit</li></ul><p>Andere Materialien werden √ºber eine Eigenschaftsnamen-Heuristik konvertiert. Das bedeutet, dass Sie je nach den Eigenschaftsnamen, die Ihre Materialien und Shader verwenden, entweder die Eigenschaften Ihres benutzerdefinierten Shaders umbenennen m√ºssen, um die Eigenschaftsnamen von URP/Lit oder PBRGraph zu verwenden, oder das Material als <a href="#custom-shaders">Custom Shader</a> exportieren m√ºssen.</p><h3 id="custom-shaders" tabindex="-1"><a class="header-anchor" href="#custom-shaders"><span>Custom Shaders</span></a></h3><p>Um benutzerdefinierte Unlit-Shader (z. B. mit ShaderGraph erstellt) zu exportieren, f√ºgen Sie dem Shader, den Sie exportieren m√∂chten, ein <code>ExportShader</code> Asset Label hinzu. Asset Labels sind am unteren Rand des Inspektors zu sehen.</p><p><img src="https://user-images.githubusercontent.com/5083203/185957781-9fae18c5-09ff-490f-8958-57e138aa0003.png" alt="2022-08-22-172029_Needle_Website_-CustomShaders-_Windows,_Mac,_Lin"></p><h4 id="einschr-nkungen" tabindex="-1"><a class="header-anchor" href="#einschr-nkungen"><span>Einschr√§nkungen</span></a></h4><ul><li>Wir unterst√ºtzen derzeit nur benutzerdefinierte <strong>Unlit</strong>-Shader ‚Äì die Konvertierung von Lit-Shadern wird nicht offiziell unterst√ºtzt.</li><li>Benutzerdefinierte Lit-Shader sind derzeit experimentell. Nicht alle Rendering-Modi werden unterst√ºtzt.</li><li>Der Empfang von Schatten auf benutzerdefinierten Shadern wird nicht unterst√ºtzt.</li><li>Skinned Meshes mit benutzerdefinierten Shadern werden nicht unterst√ºtzt.</li><li>Da es beim √úbergang von Unity zu three.js und glTF mehrere Koordinatensystem√§nderungen gibt, k√∂nnen einige √Ñnderungen erforderlich sein, damit erweiterte Effekte funktionieren. Wir versuchen, Daten beim Export zu konvertieren, erfassen aber m√∂glicherweise nicht alle F√§lle, in denen Konvertierungen erforderlich sind. <ul><li>UV-Koordinaten beginnen in Unity unten links; in glTF beginnen sie oben links.</li><li>X-Achsenwerte sind in glTF im Vergleich zu Unity gespiegelt. Dies ist eine Variante einer √Ñnderung von einem linksh√§ndigen zu einem rechtsh√§ndigen Koordinatensystem. Daten, die in Shadern verwendet werden, m√ºssen m√∂glicherweise auf der X-Achse gespiegelt werden, um korrekt angezeigt zu werden.</li></ul></li></ul><div class="hint-container note"><p class="hint-container-title">Nicht Teil der glTF-Spezifikation</p><p>Beachten Sie, dass <strong>Custom Shaders</strong> nicht offiziell Teil der glTF-Spezifikation sind. Unsere Implementierung von Custom Shadern verwendet eine Extension namens KHR_techniques_webgl, die den WebGL-Shadercode direkt in der glTF-Datei speichert. Die resultierenden Assets funktionieren in Viewern, die auf Needle Engine basieren, werden aber in anderen Viewern m√∂glicherweise nicht korrekt angezeigt.</p></div><h2 id="lightmaps-exportieren" tabindex="-1"><a class="header-anchor" href="#lightmaps-exportieren"><span>üí° Lightmaps exportieren</span></a></h2><p><img src="https://user-images.githubusercontent.com/5083203/185957005-d04c9530-07eb-40f5-b305-9822d13b79ab.png" alt="2022-08-22-171650_Needle_-_Google_Chrome"></p><p>Um Lightmaps zu exportieren, <a href="https://docs.unity3d.com/Manual/Lightmapping.html" target="_blank" rel="noopener noreferrer">generieren Sie einfach Lightmaps</a> in Unity. Lightmaps werden automatisch exportiert.</p><p>Beim Arbeiten an mehreren Szenen deaktivieren Sie &quot;Auto Generate&quot; und backen Sie Lightmaps explizit. Andernfalls verwirft Unity tempor√§re Lightmaps beim Szenenwechsel.</p><h3 id="empfohlene-lightmap-einstellungen" tabindex="-1"><a class="header-anchor" href="#empfohlene-lightmap-einstellungen"><span>Empfohlene Lightmap-Einstellungen</span></a></h3><ul><li>Lightmap Encoding: Normal Quality (anpassen unter Project Settings &gt; Player)</li><li>Progressive GPU (schneller und meist genau genug f√ºr kleine Szenen)</li><li>Non-Directional Lightmaps</li><li>Max Lightmap Size 2k (Sie k√∂nnen h√∂her gehen, aber rechnen Sie mit gro√üen Dateien)</li><li>Max 4x 2k Lightmaps pro Szene (Sie k√∂nnen h√∂her gehen, aber rechnen Sie mit gro√üen Dateien)</li><li>Compress Lightmaps AUS (erh√∂ht die Qualit√§t; wird sonst beim Export erneut komprimiert)</li></ul><p><img src="https://user-images.githubusercontent.com/5083203/185956392-f4031f45-ad13-4e6d-a14c-c8ec5c1fcfd4.png" alt="2022-08-22-171356_Needle_Website_-Lightmaps-_Windows,_Mac,Linux-"></p><h3 id="mischen-von-baked-und-non-baked-objekten" tabindex="-1"><a class="header-anchor" href="#mischen-von-baked-und-non-baked-objekten"><span>Mischen von Baked und Non-Baked Objekten</span></a></h3><p>Es gibt keine 100%ige √úbereinstimmung zwischen der Art und Weise, wie Unity Lichter und Umgebung handhabt, und wie three.js dies tut. Zum Beispiel hat Unity v√∂llig separate Codepfade f√ºr lichtgemappte und nicht-lichtgemappte Objekte (lichtgemappte Objekte erhalten kein Umgebungslicht, da dies bereits in ihre Maps gebacken ist), und three.js unterscheidet in dieser Weise nicht.</p><p>Das bedeutet, um beste Ergebnisse zu erzielen, empfehlen wir derzeit spezifische Einstellungen, wenn Sie gebackene und nicht-gebackene Objekte in einer Szene mischen:</p><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#4c4f69;--shiki-dark:#c6d0f5;--shiki-light-bg:#eff1f5;--shiki-dark-bg:#303446;"><pre class="shiki shiki-themes catppuccin-latte catppuccin-frappe vp-code"><code><span class="line"><span>Environment Lighting: Skybox</span></span>
<span class="line"><span>Ambient Intensity: 1</span></span>
<span class="line"><span>Ambient Color: black</span></span></code></pre></div><p><strong>2021.3+</strong><img src="https://user-images.githubusercontent.com/2693840/186947184-2446672f-420c-47e8-8f7d-970a7d52bf35.png" alt="20220826-175324-SqBL-Unity_pMXa-needle"></p><p><strong>2020.3+</strong><img src="https://user-images.githubusercontent.com/2693840/186947203-2d7d96c3-f566-44b4-889c-4103fac505d4.png" alt="20220826-175514-tnGc-Unity_mycs-needle"></p><p>Wenn Sie keine gebackenen Objekte in Ihrer Szene haben, sollten auch die folgenden Einstellungen korrekte Ergebnisse liefern:</p><div class="language-" data-highlighter="shiki" data-ext="" style="--shiki-light:#4c4f69;--shiki-dark:#c6d0f5;--shiki-light-bg:#eff1f5;--shiki-dark-bg:#303446;"><pre class="shiki shiki-themes catppuccin-latte catppuccin-frappe vp-code"><code><span class="line"><span>Environment Lighting: Color</span></span>
<span class="line"><span>Ambient Color: any</span></span></code></pre></div><p>Seite automatisch √ºbersetzt mit AI</p>`,54))])}const g=s(p,[["render",c]]),m=JSON.parse('{"path":"/lang/de/export.html","title":"Assets nach glTF exportieren","lang":"de-DE","frontmatter":{"title":"Assets nach glTF exportieren","head":[["meta",{"name":"og:image","content":"https://engine.needle.tools/docs/.preview/assets nach gltf exportieren_de.png"}],["meta",{"name":"og:description","content":"---\\nF√ºgen Sie Ihrer Unity-Szene eine ExportInfo-Komponente hinzu, um ein neues Webprojekt aus einem Template zu generieren, einen Link zu einem vorhandenen Webprojekt herzustellen, in das Sie exportieren m√∂chten, Abh√§ngigkeiten zu anderen Bibliotheken und Paketen einzurichten und Ihr Projekt bereitzustellen.\\nStandardm√§√üig wird Ihre Szene beim Speichern exportiert. Diese Einstellung kann ge√§ndert werden, indem Auto Export in der ExportInfo-Komponente deaktiviert wird.\\nUm Meshes, Materialien, Animationen, Texturen (...) zu exportieren, erstellen Sie ein neues GameObject in Ihrer Hierarchie und f√ºgen Sie ihm eine GltfObject-Komponente hinzu. Dies ist die Wurzel einer neuen glTF-Datei. Sie wird jedes Mal exportiert, wenn Sie eine √Ñnderung an der Szene vornehmen und speichern.\\nNur Skripte und Daten auf und innerhalb dieser Wurzelobjekte werden exportiert. Skripte und Daten au√üerhalb davon werden nicht exportiert.\\nF√ºgen Sie Ihrem Wurzelobjekt einen W√ºrfel als Kind hinzu und speichern Sie Ihre Szene. Beachten Sie, dass der Ausgabeordner assets/ (siehe Projektstruktur) nun eine neue .glb-Datei mit demselben Namen wie Ihr Wurzel-GameObject enth√§lt.\\nSie k√∂nnen die Einstellung Smart Export (√ºber Edit/Project Settings/Needle) aktivieren, um nur zu exportieren, wenn eine √Ñnderung in der Hierarchie dieses Objekts erkannt wird.\\n:::details Wie man verhindert, dass bestimmte Objekte exportiert werden\\nObjekte mit dem Tag EditorOnly werden beim Export ignoriert, einschlie√ülich ihrer Kindhierarchie.\\nBeachten Sie, dass dies dem Deaktivieren von Objekten vorzuziehen ist, da deaktivierte Objekte weiterhin exportiert werden, falls sie sp√§ter wieder eingeschaltet werden.\\n:::\\nWenn Sie Ihre Anwendung in mehrere Level oder Szenen aufteilen m√∂"}]],"description":"---\\nF√ºgen Sie Ihrer Unity-Szene eine ExportInfo-Komponente hinzu, um ein neues Webprojekt aus einem Template zu generieren, einen Link zu einem vorhandenen Webprojekt herzustellen, in das Sie exportieren m√∂chten, Abh√§ngigkeiten zu anderen Bibliotheken und Paketen einzurichten und Ihr Projekt bereitzustellen.\\nStandardm√§√üig wird Ihre Szene beim Speichern exportiert. Diese Einstellung kann ge√§ndert werden, indem Auto Export in der ExportInfo-Komponente deaktiviert wird.\\nUm Meshes, Materialien, Animationen, Texturen (...) zu exportieren, erstellen Sie ein neues GameObject in Ihrer Hierarchie und f√ºgen Sie ihm eine GltfObject-Komponente hinzu. Dies ist die Wurzel einer neuen glTF-Datei. Sie wird jedes Mal exportiert, wenn Sie eine √Ñnderung an der Szene vornehmen und speichern.\\nNur Skripte und Daten auf und innerhalb dieser Wurzelobjekte werden exportiert. Skripte und Daten au√üerhalb davon werden nicht exportiert.\\nF√ºgen Sie Ihrem Wurzelobjekt einen W√ºrfel als Kind hinzu und speichern Sie Ihre Szene. Beachten Sie, dass der Ausgabeordner assets/ (siehe Projektstruktur) nun eine neue .glb-Datei mit demselben Namen wie Ihr Wurzel-GameObject enth√§lt.\\nSie k√∂nnen die Einstellung Smart Export (√ºber Edit/Project Settings/Needle) aktivieren, um nur zu exportieren, wenn eine √Ñnderung in der Hierarchie dieses Objekts erkannt wird.\\n:::details Wie man verhindert, dass bestimmte Objekte exportiert werden\\nObjekte mit dem Tag EditorOnly werden beim Export ignoriert, einschlie√ülich ihrer Kindhierarchie.\\nBeachten Sie, dass dies dem Deaktivieren von Objekten vorzuziehen ist, da deaktivierte Objekte weiterhin exportiert werden, falls sie sp√§ter wieder eingeschaltet werden.\\n:::\\nWenn Sie Ihre Anwendung in mehrere Level oder Szenen aufteilen m√∂"},"headers":[{"level":2,"title":"üì¶ glTF-Dateien exportieren","slug":"gltf-dateien-exportieren","link":"#gltf-dateien-exportieren","children":[{"level":3,"title":"Lazy Loading und mehrere Level / Szenen","slug":"lazy-loading-und-mehrere-level-szenen","link":"#lazy-loading-und-mehrere-level-szenen","children":[]},{"level":3,"title":"Empfohlene Komplexit√§t pro glTF","slug":"empfohlene-komplexit-t-pro-gltf","link":"#empfohlene-komplexit-t-pro-gltf","children":[]},{"level":3,"title":"Prefabs","slug":"prefabs","link":"#prefabs","children":[]},{"level":3,"title":"Scene Assets","slug":"scene-assets","link":"#scene-assets","children":[]}]},{"level":2,"title":"üèá Animationen exportieren","slug":"animationen-exportieren","link":"#animationen-exportieren","children":[]},{"level":2,"title":"üåç Skybox exportieren","slug":"skybox-exportieren","link":"#skybox-exportieren","children":[]},{"level":2,"title":"‚ú® Materialien exportieren","slug":"materialien-exportieren","link":"#materialien-exportieren","children":[{"level":3,"title":"Physically Based Materials (PBR)","slug":"physically-based-materials-pbr","link":"#physically-based-materials-pbr","children":[]},{"level":3,"title":"Custom Shaders","slug":"custom-shaders","link":"#custom-shaders","children":[]}]},{"level":2,"title":"üí° Lightmaps exportieren","slug":"lightmaps-exportieren","link":"#lightmaps-exportieren","children":[{"level":3,"title":"Empfohlene Lightmap-Einstellungen","slug":"empfohlene-lightmap-einstellungen","link":"#empfohlene-lightmap-einstellungen","children":[]},{"level":3,"title":"Mischen von Baked und Non-Baked Objekten","slug":"mischen-von-baked-und-non-baked-objekten","link":"#mischen-von-baked-und-non-baked-objekten","children":[]}]}],"git":{"updatedTime":1745311490000,"contributors":[{"name":"Marcel Wiessler","username":"","email":"marcel@gaisterhand.de","commits":1}],"changelog":[{"hash":"25e22e2b0b9e4fc1e515be2b189c24864e21ac9f","time":1745311490000,"email":"marcel@gaisterhand.de","author":"Marcel Wiessler","message":"add multilanguage support"}]},"filePathRelative":"lang/de/export.md"}');export{g as comp,m as data};
